▣  String 참조 자료형


1.기본자료형
	정수 : byte,short,int,long
	실수 : float, double
	문자, 정수 : char
	불 : boolean(true,false)

	기본자료형으로 지역변수는 스택 메모리에 저장
	==, != 는 스택에 저장된 변수에 담긴값을 비교
2.참조자료형
	문자열(String)
	배열(Array)
	열거형
	클래스
	인터페이스
	...
	
	참조 자료형은 힙 영역에 객체를 생성
	참조 자료형을 담는 참조변수는 스택에 객체의 주소를 저장
	==, != 변수가 담고는 참조자료형의 주소를 비교

**  변수는 모드 스택(stack)이라는 메모리 영역에 생성
<메모리 영역 -자바는 jvm이 관리>
1)메소드영역(=데이터 영역, 클래스 영역,스태틱영역,..)
	바이트코드 파일(~.class)을 읽은 내용이 저장되는 영역
	클래스별로 상수, 정정필드(static 필드), 메소드 코드, 생성자 코드 등이 저장
2)스택영역(stack)
	메소드를 호출할 떄마다 생성되는 프레임(frame)이 저장되는 영역
	메소드 호출이 끝나면 프레임은 자동 제거
	프레임 내부에는 로컬변수(=지역변수) 스택이 있고,여기에서 기본 타입 변수와
	참조타입 변수가 생성되고 제거 됨
3)힙(heap)영역
	객체가 생성되는 영역
	객체의 번지는 메소드 영역과 스택 영역의 상수와 변수에서 참조할 수 있음
	힙에 만들어진 객체는 완성된 것만 올릴 수 있다.
	미완성인 클래스로는 객체를 생성할 수 없음(힙은 미완성된것을 올리지 못함)

** ==,!= 연산자 : 변수의 값이 같은지,같지 않은지 조사
	참조타입 변수의 값은 갹체의 번지이므로 참조타입 변수의 ==, != 연산자는
	번지를 비교하는것이 됨
	번지가 같으면 동일한 객체를 참조한는 것이고, 번지가 다르면 다른 객체를 참조하는 것

**null - 참조하는 것이 없음, 참조타입은 null을 초기값으로 사용할 수 있음
  NullPointerException : 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 때
	이 예외가 발생
	에 예외가 발생하면 예외가 발생된 곳에서 null인 상태의 참조 변수가 사용되고 있다는 의미
	이 예외를 해결하기 위해서는 참조 변수가 객체를 정확히 참조하도록 번지룰 대입해야함




	

3. String 클래스
	- 클래스 (class, 설계도, 틀), 객체(object) - 클래스로 만들어낸 실체
	- 문자열 저장 클래스 타입
	- 문자열은 큰따옴표("") 안에 표기
	

	1) String 객체 생성
		String 참조변수명 = new String("문자열");  // 문자열을 새롭게 생성, String() 생성자  - 출력은 객체
							// String() 생성자를 통해 객체를 만들고 그것을 힙에 넣어줘

		String 참조변수명 = "문자열";  // 값 - 리터럴, 같은 문자열 끼리는 객체를 공유함
     		// class 영역에 클래스 로더에 의해 String 클래스를 클래스영역에 읽혀짐(붕어빵 기계를 가져다 놓은 상태)

	2) String 클래스만이 가지고 있는 2가지 특징
		- 객체 내의 값 변경 불가능 ->  값 변경시 새로운 객체를 생성하여 작성
		- 리터럴을 바로 입력한 데이터는 문자열이 같은 경우 하나의 객체를 공유

	3) String 객체의 '+' 연산(plus operation)
		- 문자열 + 문자열  => 문자열을 연결
		- 문자열 + 기본자료형 또는 기본자료형 + 문자열  => 기본자료형을 문자열로 변환 + 문자열 연결

		- String.valueOf(값)  : String으로 변환, 생략해도 문자열 + 기본자료형을 쓰면  String.valueOf(기본자료형)을
					통해 자동으로 문자열로 변환되는 것임
				String.valueOf(기본자료형) -> 기본자료형을 String으로 변환

	4) String의 주요 메서드
		- 문자열 길이(length)  : 문자열.length( )  // 배열의 길이 : length, ArrayList에서의 길이 : size( )
		- 문자열 검색(charAt, indexOf, lastIndexOf
			. 문자열.charAt(인덱스)  : 인덱스 위치의 문자
			. 문자열.indexOf(찾는 문자) : 문자의 위치 인덱스
			. 문자열.lastIndexOf(찾는 문자) : 뒤에서부터 일치하는 문자의 위치 인덱스
			. String.valueOf(값) : boolean, char, int, long, float, double등의 값을 문자열로 변환
			. 문자열1.concat(문자열2) : 문자열 연결 
		-문자열 대체: .문자열1.replace("대체하려고 하는 문자", "대체문자"
		-문자열 잘라내기 
			substring(시작인덱스번호) : 시작부터 끝까지 잘라내기
			substring(시작인덱스번호, 끝 인덱스번호) : 시작인덱스부터 끝인덱스 -1 까지 잘라내기
			
			-문자열 분리 :문자열이 구분자를 사용하여 여러개 의 문자욜로 구성되어 있는 경우
				구분자를 기준으로 분리
				문자열.split(구분자)
	       - equals() : 두 문자열의 데이터값을 비교, 대소문자 구분

	       - equalsIgnoreCase() : 두 문자열의 데이터값을 비교, 대소문자 구분 안함

===============================
▣  참조 자료형

1. 1차원 배열
	1) 배열의 특징
		- 동일한 자료형만 묶어서 저장 가능 
                     //비교) 자바스크립트는 어떤 자료형이나 담을 수 있음
		- 생성시 크기를 지정 , 이후 크기 변경 할 수 없다
		
	2) 배열의 선언
		- 배열 선언시 어떤 자료형을 저장하는 배열인지 여부가 나타나야 함
		
		자료형[] 변수명; 
		int[] num;  // int 배열 자료형 num;
 		int num[]; 
		
		- 모든 변수는 stack에 올라간다.
			int[] a;        	a변수는 지역 변수로 스택에 만들어짐
			String[] s = null; 	s변수는 null을 담고 있음  // 가리키고 있는 객체가 없다.
				. 참조자료형의 초기값은 null을 넣어야 함, 숫자를 넣으면 에러

	3) 배열의 객체 생성
		- 여러 개의 값을 저장할 수 있는 공간
		- heap 메모리에 생성
			new 자료형[배열의 길이]
			new int[3]
			new String[5]
			new double[4]
		- 배열 객체 생성하는 시점에 크기가 지정되어야 한다. ( int[] a = new int[];  //에러)
                       
                       // 방법1
			int[] a = new int[3];
			
			a[0] = 10;
			a[1] = 5;
			a[2] = 15;
                       
			// 방법2
                   	int[] a;
			a = new int[3];
			
			a[0] = 10;
			a[1] = 5;
			a[2] = 15;

			// 방법3
			int[] a = new int[]{10,5,15};
                                      // 여기에 공간길이 넣으면 안됨
                                      // 뒷쪽 {}에서 모두 알려주기 때문
			int[] a = new int[3]{10,5,15}; //에러
                        // 방법4
			int[] a = {10,5,15};
		
		// 방법 5
                       		 int[] a;
			a = new int[]{10,20,30}
                        	주의) int[] a;
                             		 a = {10, 20, 30 } 안됨
	
		- new 키워드 
			. heap 메모리에 넣어라는 의미
			. jvm이 비워 있는 공간 객체를 생성               
                          		어느 공간에 넣었는지 알 수 없기 때문에
				  jvm은 객체의 위치정보를 리턴 해 주어야 함
			. 리턴된 값을 참조 변수(스택에 있는 변수)저장(위치 주소)

		- stack는 강제 초기화 되지 않음
		- heap 메모리는 강제 초기화 됨(jvm이 알아서 초기화 시킴)
			힙은 미완성된것을 올릴수 없기 때문에
			int - 0, double - 0.0,  참조형 - null
			long - 0L, float - 0.0f

	4) 배열 객체의 값 대입
		- 값 대입 : 참조변수명[인덱스번호] = 값;
		- 값 읽기 : 참조변수명[인덱스번호]
			
			a[0] = 2;
			a[1] = 3;

	5) 배열의 길이 : 배열명.length
			// 문자열의 길이 : length()

        6) 배열의 출력
           - for(int i=0; i<배열명.length; i++){ }
           - Arrays.toString(배열명) : 배열을 문자열로 출력


**향상된 for문(for each문)
	for(타입 변수 : 배얄이나 컬렉션 객체{
		실행할 문장
	}
	int[] num = {10, 20, 30};
	for(int n : num){// {10,20,30}
		System.out.println(n);
	}
	// 타입 : 배열에서 넘겨 받을 요소의 
	// 변수 :
	// 배열 :

=============================================


2. 2차원 배열
	- 가로 및 세로 방향으로 정렬된 배열
	- 메모리는 데이터를 1차원으로만 저장 가능
	   2차원 데이터를 저장하기 위해서는 1차원(행 단위)으로 나누어 저장
	   1차원 배열을 원소로 가지는 1차원 배열


		자료형[][]  변수명 = new 자료형[행의 길이][열의 길이]
	

		
		int[][] num = new int[2][3]; // 행의길이:2, 열길이:3
		int[][] num1 = new int[2][]; //행의 길이는 반드시 넣어 주어야 하지만
                                             // 열의 길이는 생략 가능

		int[][] num;
		num = new int[2][3];


		int[][] num = new int[2][];
		num[0] = new int[3];
		num[1] = new int[2];


		자료형[][] 참조변수명 = new 자료형[][]{{값1, 값2,..,값n}, ...{값1, 값2,..., 값n}}

		자료형[][] 참조변수명 = {{값1, 값2,..,값n}, ...{값1, 값2,..., 값n}}


	- 배열의 길이  : 행 - 배열명.length
		        열 - 배열명[행의 인덱스].length
