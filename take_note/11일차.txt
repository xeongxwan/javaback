클래스 : 설계도, 틀

클래스의 멤버 : 필드(=멤버변수), 메소드(=멤버메소드)
1. 필드(field)
	- 특성(=속성)
	- 메소드의 내부(지역변수)를 제외하고 클래스 내부의 어디에서든 선언할 수 있음
	  (cf - 지역변수는 매개변수나 메소드 내부에서 선언된 변수,for문, while문, if문
                    등 블록내부에서도 지역 변수를 선언할 수 있음)
             - 필드 선언시 초기화하지 않아도 기본값으로 자동 초기화
	   (비교 -  지역변수는 기본값이 없기 때문에 반드시 초기화 해야 함)
	- 필드는 클래스 전체에서 사용할 수 있음
	  (cf - 지역변수는 선언된 후부터 선언된 블록({}) 내부에서만 사용할 수 있음
		지역변수는 선언된 블록내에서만 사용하며)
	- 필드는 모든 접근 지정자뿐만 아니라 static, final로 지정할 수 있음
	  (cf-지역변수는 final만 지정할 수 있음)

2. this : 자기자신 객체 참조변수,  자신이 참고하는 객체의 주소
 	명확하게 멤버라는 것을 제시하고자 할때

  생성자 : new 연산자를 이용해서 클래스로부터 객체를 생성할 때 호출되어
           객체의 초기화를 담당

  객체의 초기화 : 필드를 초기화하거나(사용할 수 있게 준비시킨다) 메소드를 
             호출해서 객체를 사용할 준비를 하는 것
	생성자를 사용하지 않고는 클래스로부터 객체를 만들 수 없음

      기본생성자 :   [접근제한자] 클래스(){
	 	     객체를 초기화할 문장(코드)
                    }
     생성자를 선언 
 		[접근제한자] 클래스(매개변수,...){ 
                      // 객체를 초기화할 코드(문장)
		  }


3. 오버로딩 : 매개변수의 개수와 매개변수의 타입이 다른 것
    	- 생성자 오버로딩 : 생성자 이름이 같고, 매개변수의 개수나 매개변수의 타입이 다른 것
    	- 메소드 오버로딩 : 메소드 이름이 같고, 매개변수의 개수나 매개변수의 타입이 다른 것
                          리턴타입은 의미가 없음
    

4. this() : 자신의 다른 생성자를 호출
	반드시 첫 줄에 사용


5. 메소드 선언
	접근제한자 리턴타입 메소드명(매개변수,...){     // 선언부(메소드 시그니처(signature))
		메소드를 실행할 코드(문장)              // 구현부, 메소드 실행 블록, body
	}
   
   - 리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시
   - 메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어줌
   - 매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언
   - 메소드 실행 블록 : 실행할 코드 작성

==========================
6. static 제어자
   1) 정적(static) 멤버 : 앞에 static이 붙은 멤버
                  객체 생성없이 '클래스명.멤버명'으로 바로 사용
         . 클래스 변수(정적변수) : 클래스 내부에 생성, 객체간 공유 변수
         . 정적(static) 메서드 내부에서는 정적(static) 멤버만 사용 가능하며, 
                 클래스 내부에서 자신의 객체를 가리키는 this키워드 사용할 수 없음.

   2) 인스턴스 멤버 & 정적 멤버
       .인스턴스 멤버 : 객체 생성과 함께 만들어진다.  '참조변수명.인스턴스 멤버명'
                        멤버의 저장 공간이 객체 내부 즉 힙영역에 생성(객체에 만들어진다)
       .정적(static) 멤버 : 저정 공간이 클래스 내부 즉 class 영역(정적영역, 메서드 영역, 데이터영역)에 생성

   3) 정적 초기화 블록  
      . 인스턴스 필드의 초기화는 객체를 생성하는 시점에 이루어진다. 
   	즉 객체가 생성자에 의해 초기화 되므로 생성자 내에서 
               인스턴스 필드를 초기화 해준다. 그러나 정적필드는 객체 생성 이전에 
	사용할 수 있어야 하므로 생성자가 호출되지 않은 상태에서도 초기화 할 수 있어야 함
               (즉 생성자에서는 정적 필드를 초기화 할 수 없음)
               정적 필드는 정적 초기화 블록(static { } )에서 초기화 해 주어야 함
      . 정적초기화 블록은 클래스가 메모리에 로딩될 때 가장 먼저 실행되므로 
 	정적 필드의 초기화 코드를 넣어  주면 클래스가 로딩되는 시점에 바로 초기화

  4) main()메서드 
     자바 가상 머신(jvm)은 프로그램을 실행할 때 '실행 클래스명.main()'을 실행하므로 
      가장 먼저 실행되는 메서드인 main()메서드를 정적 메서드로 구성 
=====================================================================
7. 변수 유형에 따른 용도
   1) 지역변수(=local variable)  메소드 등의 내부에 선언
			스택영역에 위치
			메소드의 실행이 끝나면 메모리에서 소멸
			메소드가 호출 될때 실행되고 메소드 실행이 끝나면 소멸
   2) 인스턴스 변수(=멤버 필드, 인스턴스 변수, static필드 필드) : 클래스에서 필드로 선언되어 있으며,
			객체(인스턴스) 내부에 생성되며, heap 영역에 위치

   3) staic변수(=클래스 변수) : static 예약어를 사용하여 클래스 내부에 선언
			클래스 내부에 위치
			객체들이 공유하는 변수
			메소드 영역(데이터영역, 클래스영역)에 위치하며 프로그램이 끝나고 
                                             메모리를 해제할 때 소멸됨

=============================
8. package와 import
 1) package 
	- 프로젝트의 하위 폴더의 개념
	- 클래스 파일을 목적별로 묶어서 관리
	- java.lang : 자바의 가장 기본 클래스 묶음
	- java.util : 유용한 확장 클래스 묶음
	- java.awt / java.swing / javafx : 자바 그래픽 관련 클래스 묶음
	- java.io / java.nio : 자바 입출력 패키지 관련 클래스
	- 패키지마다 이름공간(namespace) 생성 : 클래스 이름의 충돌 방지
	- 반드시 첫 줄에 표시

 2) import
	- 다른 패키지의 클래스를 사용하고자 할 때
		import 상위패키지.하위패키지.클래스이름;
		import 상위패키지.하위패키지.*;
	- 클래스이름의 전체 경로(패키지.클래스)이름 사용
	 	exam07.Printer aa = new exam07.Printer();  // import하지 않을 경우

		import exam07.printer;
		printer aa = new Printer();
       	- 패키지가 다른 동일한 이름의 클래스는 두 개 이상 import할 수 없음
	  	 하나는 import 시키고, 나머지는 정식 이름을 사용
		import 해서 사용할 때는 클래스이름을 가지고 사용하기에 같은 이름이면 문제됨
	- 패키지의 모든 클래스를 한 번에 임포트 하기 위해서는 * 사용
   	  	단, *는 하위 패키지는 포함하지 않음
	- 접근제한자가 public 이어야 다른 패키지에서 import 할 수 있음

==========
9. 접근 제한자(Modifier)
	- 자바는 접근 지정자(접근제한자)를 반드시 설정하도록 강제함
	- 접근 제한자를 생략하면 default로 처리 됨
	- 멤버 및 생성자 : public > protected > default > private
	- class : public, default
  1) 멤버(필드, 메소드, 이너클래스) 및 생성자의 접근 지정자
	public 		: 모든 클래스에 사용 가능(동일 패키지의 모든 클래스, 
			  다른 패키지의 모든 클래스에서 사용 가능)
 	protected 	: 동일 패키지의 모든 클래스,
 			  다른 패키지의 자식 클래스에서 사용 가능 
	default		: 동일 패키지의 모든 클래스에서 사용 가능
			  멤버 앞에 아무것도 표기하지 않는 것
	private		: 자신의 클래스 내부에서만 사용



